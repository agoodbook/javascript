import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';
import CodeDemo from '../../../src/components/CodeDemo';

# Object

## Object.create

`Object.create()` 静态方法以一个现有对象作为原型，创建一个新对象。

<Tabs>
  <TabItem value="语法">

    `proto`
    > 新创建对象的原型对象。

    <p className="optional">`propertiesObject`</p>

    > 如果该参数被指定且不为 `undefined`，则该传入对象可枚举的自有属性将为新创建的对象添加具有对应属性名称的属性描述符。这些属性对应于 `Object.defineProperties()` 的第二个参数。

    **返回值**

    根据指定的原型对象和属性创建的新对象。

    **异常**

    如果 `proto` 既不是 `null`，也不是 Object，则抛出 TypeError。

    ```js title="用法"
    Object.create(proto);
    Object.create(proto, propertiesObject);
    ```
    通过 `Object.create()` 方法，可以利用原型链的特性来实现对象之间的继承关系，非常有用于面向对象的 JavaScript 编程。

  </TabItem>

  <TabItem value="示例">
    <CodeDemo filePath="/api/object/create.txt"/>
    <CodeDemo filePath="/api/object/create2.txt" title="建立原型链的继承关系"/>
  </TabItem>
</Tabs>

## Object.assign

从一个或多个源对象复制所有可枚举的自有属性到目标对象，并返回目标对象。

:::warning
`Object.assign()` 执行的是浅拷贝，而不是深拷贝。如果源对象的属性是对象，则只会复制对象的引用。
:::

<Tabs>
  <TabItem value="语法">

    `target`

    > 目标对象，将接收来自源对象的属性。

    `sources`

    > 一个或多个源对象，包含将被复制到目标对象的属性。


    **返回值**

    返回目标对象 `target`。


    ```js title="用法"
    Object.assign(target, source1, source2);
    ```

  </TabItem>

  <TabItem value="示例">
    <CodeDemo filePath="/api/object/assign.txt"/>
    <CodeDemo filePath="/api/object/assign2.txt" title="克隆对象"/>
  </TabItem>
</Tabs>

## Object.keys

`Object.keys()` 静态方法返回一个由给定对象自身的可枚举的字符串键*属性名组成的数组*。

```js title="示例"
const person = {
  name: 'mofan',
  age: '23',
  address: 'China',
};

console.log(Object.keys(person)); // [ 'name', 'age', 'address' ]
```

## Object.values

`Object.values()` 静态方法返回一个给定对象的自有可枚举字符串键属性值组成的数组。

```js title="示例"
const person = {
  name: 'mofan',
  age: '23',
  address: 'China',
};

console.log(Object.values(person)); // [ 'mofan', '23', 'China' ]
```

## Object.entries

`Object.entries()` 静态方法返回一个包含给定对象自有的可枚举字符串键属性的键值对的数值（二维数组）。

```js title="示例"
const person = {
  name: 'mofan',
  age: '23',
  address: 'China',
};

console.log(Object.entries(person)); // [ [ 'name', 'mofan' ], [ 'age', '23' ], [ 'address', 'China' ] ]
```

## Object.freeze

`Object.freeze()` 静态方法可以使一个对象被冻结。冻结对象可以防止扩展，并使现有的属性不可写入和不可配置。被冻结的对象不能再被更改：不能添加新的属性，不能移除现有的属性，不能更改它们的可枚举性、可配置性、可写性或值，对象的原型也不能被重新指定。`freeze()` 返回与传入的对象相同的对象。

:::tip
冻结一个对象是 JavaScript 提供的最高完整性级别保护措施。
:::

```js title="示例"
const person = {
  name: 'mofan',
  age: '23',
  address: 'China',
};

const freezePerson = Object.freeze(person);

console.log(freezePerson === person); // true

// 严格模式下抛出异常，非严格模式静默失败
// error
person.age = 30;
```

## Object.seal

`Object.seal()` 静态方法密封一个对象。密封一个对象会阻止其扩展并且使得现有属性不可配置。密封对象有一组固定的属性：不能添加新属性、不能删除现有属性或更改其可枚举性和可配置性、不能重新分配其原型。_只要现有属性的值是可写的，它们仍然可以更改_。`seal()` 返回传入的同一对象。

```js title="示例"
const person = {
  name: 'mofan',
  age: '23',
  address: 'China',
};

const sealPerson = Object.seal(person);

console.log(sealPerson === person); // true

// 非严格模式下静默失败，严格模式下抛出异常
// error
person.gender = '男';

// 可修改属性
// success-start
person.name = 'coder_mofan';
console.log(person); // { name: 'coder_mofan', age: '23', address: 'China' }
// success-end
```

:::info `Object.freeze` 和 `Object.seal` 区别
前者冻结对象，防止修改对象及其属性。已冻结的对象不可添加新属性，不可删除现有属性，也不可修改属性的值。后者密封对象，防止添加或删除属性，但可以修改现有属性。
:::

## Object.getOwnPropertyDescriptors

## Object.getPrototypeOf

## Object.defineProperty
